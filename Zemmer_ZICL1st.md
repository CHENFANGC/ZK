---
timezone: Asia/Shanghai

---


1. 我是Zemmer，后端转合约，专注defi和nft。
2. 能完成本次残酷学习。
3. 目前阶段对ZK了解了一些，没有系统学习，正好遇到，拿下。

## Notes

<!-- Content_START -->

### 2024.07.29
## zk的概念

1、允许作为证明者的一方在不透露其他信息的情况下让作为验证者的另一方相信某个事实或声明。

2、ZKP的目的是：证明我有这个事实。

3、ZKP并不是“零”知识，而是不透露除了这个事实之外的其他任何信息。

## 关于Knowledge和information的区别举例

我觉得在合约的角度，知识聚焦于交易相关概念的判断，而信息不仅包含知识，而且聚焦于单个变量的数值。

| 知识                                     | 信息                           |
| ---------------------------------------- | ------------------------------ |
| 1、某个地址拥有大于100的ETH              | 1、地址0x99拥有121.3ETH        |
| 2、某个交易的交易方属于某个DAO           | 2、区块的生成时间是12828382938 |
| 3、某个mint后但未reveal的NFT属于某个地址 |                                |
| 4、交易0x88的交易双方都是EOA             |                                |

## NP问题

### P和NP的概念

1、P问题：可以在多项式时间（而不是指数时间）内求解的问题

2、NP问题：可以在多项式时间内验证解的正确性的问题。

### NP问题特点

1、难以求解，但易于验证。

2、P问题是NP问题的子集：即P问题易于求解，也易于验证。

### NP完全问题NP Complete

1、如果能在多项式时间内解决任何一个NP完全问题,就能解决所有NP问题

2、所有NP问题都可以归约到某个NP完全问题

### 常见NP问题

1、图着色问题Graph Coloring：给定一个图和k种颜色，是否可以用这k种颜色给图的顶点着色，使得相邻顶点颜色不同？

2、汉密尔顿回路问题Hamiltonian Cycle：在给定的图中，是否存在一条经过每个顶点恰好一次的回路

3、子集和问题Subset Sum：给定一组数字和一个目标值，这组数字是否存在一个子集，其和等于目标值？

4、布尔可满足性问题Boolean Satisfiability Problem, SAT：给定一个布尔表达式，是否存在一组变量赋值使表达式为真？

5、整数分解问题Integer Factorization：给定一个大整数，找出它的质因数。

### 关于三色图

#### 1、三色图的游戏规则

1、需要地图上n块地图，一共三种颜色国家，相邻的两块颜色都不同。

2、地图遮住颜色。

3、验证者每次只能要求揭露相邻的两块地图颜色。

4、如果验证的结果是颜色不同，则验证通过，说明证明者正确。

5、验证者可以多次验证。

#### 2、三色图的刷新机制

三色图规则有一个非常巧妙的地方，就是每次验证者验证之后，整体的答案进行了刷新，证明者仍保证当前答案符合游戏规则。

#### 3、分析

1、刷新规则代表了证明者可以证明给验证者一个事实：我这次是对的，也就是这个局部是对的。

2、但不能证明一个事实：我这次的其他地方也是对的，也就是整体是对的。

3、对于验证者来说，他清楚每次有1/2的概率证明者可能出错。

4、然而，如果证明者确实有三色图的答案，那么就不可能出现验证错误的情况。

5、这就像抛硬币，虽然每次有1/2的可能性抛出头像那一面，但是如果你每次都抛出头像面，那么我可以认为你这个硬币只有一面。

6、感觉这是一种无限逼近的证明，不是完备的证明。


### 2024.07.30

## ZK的两种技术：ZK-snarks和ZK-starks的区别

| 特性         | zk-SNARKs                                         | zk-STARKs                                          |
| ------------ | ------------------------------------------------- | -------------------------------------------------- |
| **扩展性**   | 需要可信设置，扩展性较差                          | 不需要可信设置，扩展性更强                         |
| **安全性**   | 依赖复杂数学假设（如椭圆曲线和Pairing-based加密） | 基于哈希函数，依赖较少的假设，更加简单和可靠       |
| **证明尺寸** | 证明尺寸较小，验证时间较短，适合在区块链上使用    | 证明尺寸较大，生成和验证的资源消耗较大             |
| **应用率**   | 已有较成熟的开发生态，应用较广泛                  | 技术更先进，但应用较少，开发生态还不够成熟         |
| **可信验证** | 需要可信设置来生成公共参数                        | 不需要可信设置，证明是完全透明的，任何人都可以验证 |

## layer2的zk技术

optimistic：假设所有交易都有效，如果出问题再检测。

zk-rollup：需要每个交易都附带证明

### 数据存储方式三种

rollup：

validadium：数据存在链下，有点像预制菜，菜单是有效性证明！预制菜本身代表线下储存。

volition：数据存储方式：结合了zk-rollup和validadium结合。

### rollup的项目

lookpring

zksync

starknet

# 今天学习结果很差，非常松散，需要系统的针对某一些基础进行深挖。

### 2024.07.31
今天只学了一个zk游戏，和三色图的有点类似，具体如下
## 抛硬币猜测色彩游戏

### 要求

verifier在不看页面的前提下，通过交互式来判断页面只有一个颜色还是两个颜色。

### 前提条件

1、页面上有一个矩形图形，矩形对称轴将其分成两部分。

2、每个部分可能有两个颜色，分别是绿色和紫色。也有可能都是一个颜色，比如全绿色或全紫色。

3、硬币有两面head和tail。

4、verifier是色盲，无法分辨页面颜色，但可以分辨硬币是哪一面。

5、prover不是色盲，可以分辨页面颜色。

6、prover知道verifier会投掷硬币，且会根据投掷硬币结果去决定是否翻转页面。

7、prover和verifier都诚实。

### 交互验证流程

1、prover将页面给verifier。

2、verifier抛硬币，并自己设定规则来根据硬币是哪一面来决定是否给页面翻面。假设当前游戏规则是抛出heads，则翻转页面。

3、verifier将操作完的页面给prover，prover收到该页面。

#### 当前交互总结

| 掌握的知识                       | prover                     | verifier |
| -------------------------------- | -------------------------- | -------- |
| 页面是一个颜色还是两个           | 是                         | 否       |
| verifier投掷硬币的是head还是tail | 否                         | 是       |
| verifier是否翻转了页面           | 如果页面两色则是，单色则否 | 是       |

1、截止当前步骤，verifier掌握的信息只有他投掷的硬币是哪一面。

2、prover知道verifier抛了硬币，但不确定verifier是哪一面，因为prover和verifier并没有在游戏之前商量好是抛哪一面才翻转。

3、prover掌握的信息是页面的初始原色，以及页面是否被翻转这两个信息。而如果页面初始是两个颜色，他是可以100%掌握页面是否被翻转这个信息的。但如果页面初始是一个颜色，他无法掌握页面是否被翻转这个信息。

### 继续交互流程

4、prover需要猜测verifier设定的翻转规则，有两种：第一种是抛head翻转，而tail不翻转。第二种是抛tail翻转而head不翻转。

5、prover根据猜测的结果和页面的情况来回复verifier说：“你的coin抛了head”或“你的coin抛了tail"

6、verifier得到这个消息，和自己实际抛售的结果进行比较。

#### 当前交互总结

| 掌握的知识                                         | prover                     | verifier |
| -------------------------------------------------- | -------------------------- | -------- |
| 页面是一个颜色还是两个                             | 是                         | 否       |
| verifier投掷硬币的是head还是tail                   | 否                         | 是       |
| verifier是否翻转了页面                             | 如果页面两色则是，单色则否 | 是       |
| prover猜测的硬币面是否和verifier实际抛的硬币面一样 | 否                         | 是       |

### 此轮验证结束，循环开始下一轮验证。

### 举例

#### 前提1：

| 页面颜色 | verifier的规则 | prover的规则 |
| -------- | -------------- | ------------ |
| 2        | head -> 翻     | 翻 -> head   |

| 次数 | verifier 抛出真实 | prover看到结果 | Prove的回答 | Prover回答和verifier的是否一致 |
| ---- | ----------------- | -------------- | ----------- | ------------------------------ |
| 1    | head              | 翻了           | head        | 是                             |
| 2    | tail              | 没翻           | tail        | 是                             |

所以结果：这种情况下，永远一致。因此：正确率100%，页面颜色是2。

#### 前提2：

| 页面颜色 | verifier的规则 | prover的规则 |
| -------- | -------------- | ------------ |
| 2        | head -> 翻     | 不翻 -> head |

| 次数 | verifier 抛出真实 | prover看到结果 | Prove的回答 | Prover回答和verifier的是否一致 |
| ---- | ----------------- | -------------- | ----------- | ------------------------------ |
| 1    | head              | 翻了           | tail        | 否                             |
| 2    | tail              | 没翻           | head        | 否                             |

所以结果：这种情况下，永远不一致。因此：正确率0%，页面颜色是2。

#### 前提3：

| 页面颜色 | verifier的规则 | prover的规则 |
| -------- | -------------- | ------------ |
| 2        | head -> 不翻   | 翻 -> head   |

| 次数 | verifier 抛出真实 | prover看到结果 | Prove的回答 | Prover回答和verifier的是否一致 |
| ---- | ----------------- | -------------- | ----------- | ------------------------------ |
| 1    | head              | 没翻           | tail        | 否                             |
| 2    | tail              | 翻了           | head        | 否                             |

所以结果：这种情况下，永远不一致。因此：正确率0%，页面颜色是2。

#### 前提4：

| 页面颜色 | verifier的规则 | prover的规则 |
| -------- | -------------- | ------------ |
| 2        | head -> 不翻   | 不翻 -> head |

| 次数 | verifier 抛出真实 | prover看到结果 | Prove的回答 | Prover回答和verifier的是否一致 |
| ---- | ----------------- | -------------- | ----------- | ------------------------------ |
| 1    | head              | 没翻           | head        | 是                             |
| 2    | tail              | 翻了           | tail        | 是                             |

所以结果：这种情况下，永远一致。因此：正确率100%，页面颜色是2。

#### 前提5678：

在这种情况下，由于prover看到的结果是没变化的，因此prover不能确定是否verifier是否进行了翻转，进而prover自己设置什么规则，都不可能无因有果，最后prover的回复是随机回复，无法确定的。

| 页面颜色 | verifier的规则 | prover的规则 |
| -------- | -------------- | ------------ |
| 1        | head -> 翻     | 翻 -> head   |
| 1        | head -> 翻     | 不翻 -> head |
| 1        | head -> 不翻   | 翻 -> head   |
| 1        | head -> 不翻   | 不翻 -> head |

| 次数 | verifier 抛出真实 | prover看到结果 | Prove的回答 | Prover回答和verifier的是否一致 |
| ---- | ----------------- | -------------- | ----------- | ------------------------------ |
| 1    | head              | 没变化         | 随机回答    | 不确定                         |
| 2    | tail              | 没变化         | 随机回答    | 不确定                         |

所以结果：这种情况下，回答有时候正确有时候错误。因此：正确率可能会在50%附近浮动（未必，要根据prover的性格来确定），页面颜色是1。

### 结论

1、如果prover的回答100%正确或者100%错误，则verifier判断此页面为2色。

2、如果prover的回答不是100%正确或者100%错误，则verifier判断此页面为1色。

## 游戏结论
1、zk需要将一个复杂问题从数学上转化为概率问题。
2、而且这个概率问题需要通过多轮独立的挑战验证来实现统计。

<!-- Content_END -->
